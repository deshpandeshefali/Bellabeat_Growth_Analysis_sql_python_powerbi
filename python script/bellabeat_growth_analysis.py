# -*- coding: utf-8 -*-
"""fitbit1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fjQSXSmnCZ19u5u1k-2fYfn6CPncZFkK
"""

from google.colab import drive
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# consistent style for the visualizations
sns.set_style("whitegrid")

# 1. Mount your Google Drive
drive.mount('/content/drive')

# 2. Define the path to your data
file_path = '/content/drive/MyDrive/Fitness_Data/dailyActivity_merged.csv'

# 3. Load the data using pandas
daily_activity = pd.read_csv(file_path)

# Display first few rows to confirm
daily_activity.head()

# 2. Define the path to your data
file_path_2 = '/content/drive/MyDrive/Fitness_Data/dailyIntensities_merged.csv'

# 3. Load the data using pandas
daily_intensities = pd.read_csv(file_path_2)

# Display first few rows to confirm
daily_intensities.head()

# 2. Define the path to your data
file_path_3 = '/content/drive/MyDrive/Fitness_Data/heartrate_seconds_merged.csv'

# 3. Load the data using pandas
heart_rate = pd.read_csv(file_path_3)

# Display first few rows to confirm
heart_rate.head()

# 2. Define the path to your data
file_path_4 = '/content/drive/MyDrive/Fitness_Data/minuteCaloriesNarrow_merged.csv'

# 3. Load the data using pandas
minute_calories = pd.read_csv(file_path_4)

# Display first few rows to confirm
minute_calories.head()

# 2. Define the path to your data
file_path_5 = '/content/drive/MyDrive/Fitness_Data/minuteIntensitiesNarrow_merged.csv'

# 3. Load the data using pandas
minute_intensities = pd.read_csv(file_path_5)

# Display first few rows to confirm
minute_intensities.head()

# 2. Define the path to your data
file_path_6 = '/content/drive/MyDrive/Fitness_Data/minuteMETsNarrow_merged.csv'

# 3. Load the data using pandas
minute_met = pd.read_csv(file_path_6)

# Display first few rows to confirm
minute_met.head()

# 2. Define the path to your data
file_path_7 = '/content/drive/MyDrive/Fitness_Data/minuteStepsNarrow_merged.csv'

# 3. Load the data using pandas
minute_steps = pd.read_csv(file_path_7)

# Display first few rows to confirm
minute_steps.head()

# 2. Define the path to your data
file_path_8 = '/content/drive/MyDrive/Fitness_Data/sleepDay_merged.csv'

# 3. Load the data using pandas
sleep_day = pd.read_csv(file_path_8)

# Display first few rows to confirm
sleep_day.head()

# 2. Define the path to your data
file_path_9 = '/content/drive/MyDrive/Fitness_Data/weightLogInfo_merged.csv'

# 3. Load the data using pandas
weight_info = pd.read_csv(file_path_9)

# Display first few rows to confirm
weight_info.head()

# 2. Define the path to your data
file_path_10 = '/content/drive/MyDrive/Fitness_Data/hourlyIntensities_merged.csv'

# 3. Load the data using pandas
hourly_intensities = pd.read_csv(file_path_10)

# Display first few rows to confirm
hourly_intensities.head()

# 1. Load data
# daily_activity = pd.read_csv('dailyActivity_merged.csv')

# 2. Convert 'ActivityDate' from string to proper datetime format
daily_activity['ActivityDate'] = pd.to_datetime(daily_activity['ActivityDate'])

# 3. Extract the Day of the Week (e.g., 'Monday', 'Tuesday')
# Note: The strftime('%A') method gives the full weekday name.
daily_activity['DayOfWeek'] = daily_activity['ActivityDate'].dt.strftime('%A')

# Group the data and calculate the average (mean)
avg_activity_by_day = daily_activity.groupby('DayOfWeek')[['TotalSteps', 'Calories']].mean().reset_index()

# Optional: Define a specific order for days of the week for plotting
day_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
daily_activity['DayOfWeek'] = pd.Categorical(daily_activity['DayOfWeek'], categories=day_order, ordered=True)
daily_activity = daily_activity.sort_values('DayOfWeek')

# Save the output file (optional, as per plan)
avg_activity_by_day.to_csv('avg_activity_by_day.csv', index=False)

# Page 1 - Visualizations
# Use the daily_intensities DataFrame

# 1. Convert 'ActivityDay' to datetime and extract Day of the Week
daily_intensities['ActivityDay'] = pd.to_datetime(daily_intensities['ActivityDay'])
daily_intensities['DayOfWeek'] = daily_intensities['ActivityDay'].dt.strftime('%A')

# 2. Create the 'TotalActiveMinutes' column
daily_intensities['TotalActiveMinutes'] = (
    daily_intensities['VeryActiveMinutes'] +
    daily_intensities['FairlyActiveMinutes'] +
    daily_intensities['LightlyActiveMinutes']
)

# 3. Group and calculate the average TotalActiveMinutes
avg_active_minutes_by_day = daily_intensities.groupby('DayOfWeek')['TotalActiveMinutes'].mean().reset_index()

# Sort by day order (using the 'day_order' from the previous step)
daily_intensities['DayOfWeek'] = pd.Categorical(daily_intensities['DayOfWeek'], categories=day_order, ordered=True)
daily_intensities = daily_intensities.sort_values('DayOfWeek')

plt.figure(figsize=(10, 6))
sns.lineplot(x='DayOfWeek', y='TotalSteps', data=avg_activity_by_day, marker='o', color='green')
plt.title('Average Total Steps by Day of the Week')
plt.xlabel('Day of Week')
plt.ylabel('Average Total Steps')
plt.xticks(rotation=45) # Rotate x-axis labels for readability
plt.tight_layout()
plt.show()

# 1. Calculate the average TotalSteps per user
avg_steps_per_user = daily_activity.groupby('Id')['TotalSteps'].mean().reset_index()
avg_steps_per_user.rename(columns={'TotalSteps': 'AvgSteps'}, inplace=True)

# 2. Define the categorization function based on PDF logic
def categorize_user(steps):
    if steps > 10000:
        return 'Very Active'
    elif steps >= 7500: # 7500 to 9999 steps
        return 'Active'
    elif steps >= 5000: # 5000 to 7499 steps
        return 'Light Active'
    else: # steps < 5000
        return 'Sedentary'

avg_steps_per_user['User_Segment'] = avg_steps_per_user['AvgSteps'].apply(categorize_user)

# 3. Group and count unique users for the final output
user_segmentation = avg_steps_per_user.groupby('User_Segment')['Id'].nunique().reset_index()
user_segmentation.rename(columns={'Id': 'User_Count'}, inplace=True)

# Save the final output file
user_segmentation.to_csv('user_segmentation_by_avg_steps.csv', index=False)

plt.figure(figsize=(8, 8))
# Pie chart properties to create the donut effect (wedgeprops)
plt.pie(
    user_segmentation['User_Count'],
    labels=user_segmentation['User_Segment'],
    autopct='%1.1f%%',
    startangle=90,
    pctdistance=0.85, # Position of the percentage text
    wedgeprops={'edgecolor': 'white', 'width': 0.3} # 'width' creates the donut hole
)
plt.title('Count of Users by User Segment (Average Steps)')
plt.legend(title="User Segments", loc="best")
plt.tight_layout()
plt.savefig('donut_chart_user_segmentation.png')

active_minutes_pivot = daily_intensities.groupby('DayOfWeek')[
    ['VeryActiveMinutes', 'FairlyActiveMinutes', 'LightlyActiveMinutes']
].mean().reset_index()

# Ensure day order is correct for plotting
day_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
active_minutes_pivot['DayOfWeek'] = pd.Categorical(active_minutes_pivot['DayOfWeek'], categories=day_order, ordered=True)
active_minutes_pivot = active_minutes_pivot.sort_values('DayOfWeek')

# Plotting the stacked bar chart
active_minutes_pivot.set_index('DayOfWeek').plot(
    kind='bar',
    stacked=True,
    figsize=(12, 7)
)
plt.title('Average Active Minutes Breakdown by Day of the Week')
plt.xlabel('Day of Week')
plt.ylabel('Average Minutes')
plt.xticks(rotation=45)
plt.legend(title='Activity Intensity')
plt.tight_layout()
plt.savefig('stacked_bar_avg_active_minutes.png')

plt.figure(figsize=(10, 6))
sns.barplot(
    x='DayOfWeek',
    y='Calories',
    data=avg_activity_by_day,
    palette='viridis' # Use a color palette
)
plt.title('Average Calories Burned by Day of the Week')
plt.xlabel('Day of Week')
plt.ylabel('Average Calories')
plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig('bar_chart_avg_calories_burned.png')

# The 'Time' column needs to be converted and 'Value' is the heart rate.

# Convert Time to datetime and extract Day Name
heart_rate['Time'] = pd.to_datetime(heart_rate['Time'])

def categorize_heartrate(value):
    if value < 60:
        return 'Rest'
    elif value > 120:
        return 'Active'
    else: # 60 <= Value <= 120
        return 'Normal'

heart_rate['Heart Rate Category'] = heart_rate['Value'].apply(categorize_heartrate)

# For visualization 1: Stacked Chart: Count of user IDs by Heart Rate Category
hr_category_counts = heart_rate.groupby(['Id', 'Heart Rate Category']).size().reset_index(name='Count')

def categorize_met(mets):
    if mets < 40:
        return 'Sedentary'
    elif mets < 80: # 40 to 79 (Note: PDF has 10 <= METs < 80, but 10 is redundant given Sedentary < 40)
        return 'Light'
    elif mets <= 120: # 80 to 120
        return 'Moderate'
    elif mets > 130:
        return 'Vigorous'
    else: # 121 to 130
        return 'Unclassified/Gap'

minute_met['MET Category'] = minute_met['METs'].apply(categorize_met)

# For visualization 3 & 4: Line Chart: Count of user IDs by MET Category & METs by Quarter
met_category_counts = minute_met.groupby(['Id', 'MET Category']).size().reset_index(name='Count')

# Page 2 Visualizations
# Uses hr_category_counts (calculated above)
plt.figure(figsize=(12, 7))
sns.histplot(
    data=hr_category_counts,
    x='Id',
    weights='Count',
    hue='Heart Rate Category',
    multiple='stack',
    shrink=0.8
)
plt.title('Total Heart Rate Readings by User ID and Category (Stacked)')
plt.xlabel('User ID')
plt.ylabel('Total Count of Readings')
plt.tight_layout()
plt.savefig('stacked_chart_heart_rate_category.png')

daily_calories = daily_activity.groupby('DayOfWeek')['Calories'].sum().reset_index()

# Ensure day order
daily_calories['DayOfWeek'] = pd.Categorical(daily_calories['DayOfWeek'], categories=day_order, ordered=True)
daily_calories = daily_calories.sort_values('DayOfWeek')

# Plotting the Area Chart
plt.figure(figsize=(10, 6))
plt.fill_between(
    daily_calories['DayOfWeek'],
    daily_calories['Calories'],
    color="skyblue",
    alpha=0.4
)
plt.plot(daily_calories['DayOfWeek'], daily_calories['Calories'], color="Slateblue", alpha=0.6)
plt.title('Total Calories Burned by Day of the Week')
plt.xlabel('Day of Week')
plt.ylabel('Total Calories Burned')
plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig('area_chart_daily_calories_burned.png')

# Page 3 visualizations
# Load the tables
# minute_steps = pd.read_csv('minuteStepsNarrow_merged.csv')
# minute_calories = pd.read_csv('minuteCaloriesNarrow_merged.csv')
# hourly_intensities = pd.read_csv('hourlyIntensities_merged.csv')

# 1. minuteStepsNarrow_merged: Extract Hour, Day Name from 'Activity Minute'
minute_steps['ActivityMinute'] = pd.to_datetime(minute_steps['ActivityMinute'])
minute_steps['Hour'] = minute_steps['ActivityMinute'].dt.hour
minute_steps['Day Name'] = minute_steps['ActivityMinute'].dt.strftime('%A')

# 2. minuteCaloriesNarrow_merged: Extract Hour, Day Name from 'ActivityMinute'
minute_calories['ActivityMinute'] = pd.to_datetime(minute_calories['ActivityMinute'])
minute_calories['Hour'] = minute_calories['ActivityMinute'].dt.hour
minute_calories['Day Name'] = minute_calories['ActivityMinute'].dt.strftime('%A')

# 3. hourly Intensities_merged: Extract Hour from 'ActivityHour'
hourly_intensities['ActivityHour'] = pd.to_datetime(hourly_intensities['ActivityHour'])
hourly_intensities['Hour'] = hourly_intensities['ActivityHour'].dt.hour

# Aggregate by Hour
hourly_calories = minute_calories.groupby('Hour')['Calories'].mean().reset_index()

plt.figure(figsize=(10, 6))
sns.lineplot(x='Hour', y='Calories', data=hourly_calories, marker='o')
plt.title('Hourly Average Calorie Expenditure Trend')
plt.xlabel('Hour of Day (24h)')
plt.ylabel('Average Calories Burned')
plt.xticks(range(24))
plt.tight_layout()
plt.savefig('line_chart_hourly_calories.png')

# Aggregate by Hour
hourly_avg_intensity = hourly_intensities.groupby('Hour')['AverageIntensity'].mean().reset_index()

plt.figure(figsize=(10, 6))
plt.fill_between(
    hourly_avg_intensity['Hour'],
    hourly_avg_intensity['AverageIntensity'],
    color="lightcoral",
    alpha=0.4
)
plt.plot(hourly_avg_intensity['Hour'], hourly_avg_intensity['AverageIntensity'], color="darkred", alpha=0.6)
plt.title('Average Activity Intensity per Hour')
plt.xlabel('Hour of Day (24h)')
plt.ylabel('Average Intensity')
plt.xticks(range(24))
plt.tight_layout()
plt.savefig('area_chart_hourly_intensity.png')

# Aggregate by Hour
hourly_avg_intensity = hourly_intensities.groupby('Hour')['AverageIntensity'].mean().reset_index()

plt.figure(figsize=(10, 6))
plt.fill_between(
    hourly_avg_intensity['Hour'],
    hourly_avg_intensity['AverageIntensity'],
    color="lightcoral",
    alpha=0.4
)
plt.plot(hourly_avg_intensity['Hour'], hourly_avg_intensity['AverageIntensity'], color="darkred", alpha=0.6)
plt.title('Average Activity Intensity per Hour')
plt.xlabel('Hour of Day (24h)')
plt.ylabel('Average Intensity')
plt.xticks(range(24))
plt.tight_layout()
plt.savefig('area_chart_hourly_intensity.png')

# Page 4 visualizations
# Load the sleep data
# sleep_day = pd.read_csv('sleepDay_merged.csv')

# 1. Extract Day Name from 'SleepDay' and convert to datetime
sleep_day['SleepDay'] = pd.to_datetime(sleep_day['SleepDay'])
sleep_day['Day Name'] = sleep_day['SleepDay'].dt.strftime('%A')

# 2. Calculate 'Time Awake In Bed'
sleep_day['Time Awake In Bed'] = sleep_day['TotalTimeInBed'] - sleep_day['TotalMinutesAsleep']

# Load the weight/BMI data
# weight_log_info = pd.read_csv('weightLogInfo_merged.csv')

# Define the categorization function based on BMI
def categorize_bmi(bmi):
    if bmi < 18.5:
        return 'Underweight'
    elif bmi < 25: # 18.5 <= BMI < 25
        return 'Normal'
    elif bmi < 30: # 25 <= BMI < 30
        return 'Overweight'
    else: # BMI >= 30
        return 'Obese'

# Assuming 'BMI' is the column with the calculated BMI value
weight_info['Health Status'] = weight_info['BMI'].apply(categorize_bmi)

# Prepare for visualization: Count of users by Health Status
health_status_counts = weight_info.groupby('Health Status')['Id'].nunique().reset_index()
health_status_counts.rename(columns={'Id': 'User_Count'}, inplace=True)

# Aggregate 'Time Awake In Bed' by Day Name
avg_time_awake = sleep_day.groupby('Day Name')['Time Awake In Bed'].mean().reset_index()

# Ensure day order
avg_time_awake['Day Name'] = pd.Categorical(avg_time_awake['Day Name'], categories=day_order, ordered=True)
avg_time_awake = avg_time_awake.sort_values('Day Name')

plt.figure(figsize=(10, 6))
sns.barplot(
    x='Day Name',
    y='Time Awake In Bed',
    data=avg_time_awake,
    palette='Reds'
)
plt.title('Average Time Awake In Bed by Day of the Week (Minutes)')
plt.xlabel('Day of Week')
plt.ylabel('Average Minutes Awake In Bed')
plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig('bar_chart_avg_time_awake_in_bed.png')

plt.figure(figsize=(8, 8))

# Create a list for the colors to ensure consistency
colors = ['#FFC300', '#DAF7A6', '#FF5733', '#C70039']

# Pie chart properties to create the donut effect
plt.pie(
    health_status_counts['User_Count'],
    labels=health_status_counts['Health Status'],
    autopct='%1.1f%%',
    startangle=90,
    pctdistance=0.85,
    wedgeprops={'edgecolor': 'white', 'width': 0.3},
    colors=colors
)
plt.title('User Count by BMI-based Health Status')
plt.legend(title="Health Status", loc="best")
plt.tight_layout()
plt.savefig('donut_chart_health_status.png')